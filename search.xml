<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>github pages &amp; hexo 搭建个人博客</title>
    <url>/2021/07/13/hexo-next-github/</url>
    <content><![CDATA[<p>本文仅作为个人 <a href="https://docs.github.com/en/pages"><code>github pages</code></a> 搭建 <a href="https://hexo.io/"><code>hexo</code></a> 博客记录，主题选择 <a href="https://theme-next.js.org/"><code>next</code></a>。</p>
<h2 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><blockquote>
<p><a href="https://docs.github.com/en/pages">Github Pages</a></p>
</blockquote>
<p>首先，你得有个 <code>Github</code> 帐号，然后参考以上文档，搭建一个 <code>yourname.github.io</code> 站点（<code>github pages</code> 支持<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/about-custom-domains-and-github-pages">自备域名</a>）。</p>
<span id="more"></span>

<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><blockquote>
<p><a href="https://hexo.io/zh-cn/docs/index.html">Hexo Docs</a></p>
</blockquote>
<p>官方提供中文文档，具体不再赘述。</p>
<h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><blockquote>
<p><a href="https://theme-next.js.org/docs/">Next Docs</a></p>
</blockquote>
<p>官方文档就是用的 <code>Next</code> 的博客，可以说很原汁原味，顶部有导航栏，sidebar 也提供了搜索功能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.github.com/en/pages">Github Pages</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html">Hexo Docs</a></li>
<li><a href="https://theme-next.js.org/docs/">Next Docs</a></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Helm应用包管理器</title>
    <url>/2021/07/17/helm/</url>
    <content><![CDATA[<h2 id="为什么需要Helm？"><a href="#为什么需要Helm？" class="headerlink" title="为什么需要Helm？"></a>为什么需要Helm？</h2><p>K8S上的应用对象，都是由特定的资源描述组成，包括deployment、service等。都保存各自文件中或者集中写到一个配置文件。然后kubectl apply –f 部署。</p>
<p><img src="https://cdn.jsdelivr.net/gh/stupid-yu/cdn/img/helm-vs-yaml.png"></p>
<p>如果应用只由一个或几个这样的服务组成，上面部署方式足够了。</p>
<p>而对于一个复杂的应用，会有很多类似上面的资源描述文件，例如微服务架构应用，组成应用的服务可能多达十个，几十个。如果有更新或回滚应用的需求，可能要修改和维护所涉及的大量资源文件，而这种组织和管理应用的方式就显得力不从心了。</p>
<p>且由于缺少对发布过的应用版本管理和控制，使Kubernetes上的应用维护和更新等面临诸多的挑战，主要面临以下问题：</p>
<ul>
<li><p><strong>如何将这些服务作为一个整体管理</strong></p>
</li>
<li><p><strong>这些资源文件如何高效复用</strong></p>
</li>
<li><p><strong>不支持应用级别的版本管理</strong></p>
</li>
</ul>
<span id="more"></span>

<h2 id="Helm-介绍"><a href="#Helm-介绍" class="headerlink" title="Helm 介绍"></a>Helm 介绍</h2><p>Helm是一个Kubernetes的包管理工具，就像Linux下的包管理器，如yum/apt等，可以很方便的将之前打包好的yaml文件部署到kubernetes上。</p>
<p>Helm有两个重要概念：</p>
<ul>
<li><p><strong>helm：</strong> 一个命令行客户端工具，主要用于Kubernetes应用chart的创建、打包、发布和管理。</p>
</li>
<li><p><strong>Chart：</strong> 应用描述，一系列用于描述 k8s 资源相关文件的集合。</p>
</li>
<li><p><strong>Release：</strong> 基于Chart的部署实体，一个 chart 被 Helm 运行后将会生成对应的一个 release；将在k8s中创建出真实运行的资源对象。</p>
</li>
</ul>
<h2 id="Helm-v3-变化"><a href="#Helm-v3-变化" class="headerlink" title="Helm v3 变化"></a>Helm v3 变化</h2><p><strong>2019年11月13日，</strong> Helm团队发布 <code>Helm v3 </code>的第一个稳定版本。</p>
<p><strong>该版本主要变化如下：</strong></p>
<h3 id="架构变化"><a href="#架构变化" class="headerlink" title="架构变化"></a>架构变化</h3><p><strong>最明显的变化是 <code>Tiller </code>的删除</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/stupid-yu/cdn/img/helm-arch.png"></p>
<h3 id="Release名称可以在不同命名空间重用"><a href="#Release名称可以在不同命名空间重用" class="headerlink" title="Release名称可以在不同命名空间重用"></a><code>Release</code>名称可以在不同命名空间重用</h3><h3 id="支持将-Chart-推送至-Docker-镜像仓库中"><a href="#支持将-Chart-推送至-Docker-镜像仓库中" class="headerlink" title="支持将 Chart 推送至 Docker 镜像仓库中"></a>支持将 Chart 推送至 Docker 镜像仓库中</h3><h3 id="使用JSONSchema验证chart-values"><a href="#使用JSONSchema验证chart-values" class="headerlink" title="使用JSONSchema验证chart values"></a>使用JSONSchema验证chart values</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1）为了更好地协调其他包管理者的措辞 <code>Helm CLI </code>个别更名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm delete` 更名为 `helm uninstall</span><br><span class="line">helm inspect` 更名为 `helm show</span><br><span class="line">helm fetch` 更名为 `helm pull</span><br></pre></td></tr></table></figure>

<p>但以上旧的命令当前仍能使用。</p>
<p>2）移除了用于本地临时搭建 <code>Chart Repository </code>的 <code>helm serve</code> 命令。</p>
<p>3）自动创建名称空间</p>
<p>在不存在的命名空间中创建发行版时，Helm 2创建了命名空间。Helm 3遵循其他Kubernetes对象的行为，如果命名空间不存在则返回错误。</p>
<p>4） 不再需要<code>requirements.yaml</code>, 依赖关系是直接在<code>chart.yaml</code>中定义。 </p>
<h2 id="Helm客户端"><a href="#Helm客户端" class="headerlink" title="Helm客户端"></a>Helm客户端</h2><h3 id="部署Helm客户端"><a href="#部署Helm客户端" class="headerlink" title="部署Helm客户端"></a>部署Helm客户端</h3><p>Helm客户端下载地址：<a href="https://github.com/helm/helm/releases">https://github.com/helm/helm/releases</a></p>
<p>解压移动到/usr/bin/目录即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#目前最新版 3.6.0</span><br><span class="line">wget https://get.helm.sh/helm-v3.6.0-linux-amd64.tar.gz</span><br><span class="line">tar zxvf helm-v3.6.0-linux-amd64.tar.gz </span><br><span class="line">mv linux-amd64/helm /usr/bin/</span><br></pre></td></tr></table></figure>

<h3 id="Helm常用命令"><a href="#Helm常用命令" class="headerlink" title="Helm常用命令"></a>Helm常用命令</h3><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>创建一个chart并指定名字</td>
</tr>
<tr>
<td>dependency</td>
<td>管理chart依赖</td>
</tr>
<tr>
<td>get</td>
<td>下载一个release。可用子命令：all、hooks、manifest、notes、values</td>
</tr>
<tr>
<td>history</td>
<td>获取release历史</td>
</tr>
<tr>
<td>install</td>
<td>安装一个chart</td>
</tr>
<tr>
<td>list</td>
<td>列出release</td>
</tr>
<tr>
<td>package</td>
<td>将chart目录打包到chart存档文件中</td>
</tr>
<tr>
<td>pull</td>
<td>从远程仓库中下载chart并解压到本地  # helm pull stable/mysql –untar</td>
</tr>
<tr>
<td>repo</td>
<td>添加，列出，移除，更新和索引chart仓库。可用子命令：add、index、list、remove、update</td>
</tr>
<tr>
<td>rollback</td>
<td>从之前版本回滚</td>
</tr>
<tr>
<td>search</td>
<td>根据关键字搜索chart。可用子命令：hub、repo</td>
</tr>
<tr>
<td>show</td>
<td>查看chart详细信息。可用子命令：all、chart、readme、values</td>
</tr>
<tr>
<td>status</td>
<td>显示已命名版本的状态</td>
</tr>
<tr>
<td>template</td>
<td>本地呈现模板</td>
</tr>
<tr>
<td>uninstall</td>
<td>卸载一个release</td>
</tr>
<tr>
<td>upgrade</td>
<td>更新一个release</td>
</tr>
<tr>
<td>version</td>
<td>查看helm客户端版本</td>
</tr>
</tbody></table>
<h3 id="配置国内Chart仓库"><a href="#配置国内Chart仓库" class="headerlink" title="配置国内Chart仓库"></a>配置国内Chart仓库</h3><ul>
<li>微软仓库（<a href="http://mirror.azure.cn/kubernetes/charts/">http://mirror.azure.cn/kubernetes/charts/</a>) 这个仓库强烈推荐，基本上官网有的chart这里都有。</li>
<li>阿里云仓库（<a href="https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts">https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</a>) 长时间未更新，版本较旧</li>
<li>官方仓库（<a href="https://hub.kubeapps.com/charts/incubator">https://hub.kubeapps.com/charts/incubator</a>) 官方chart仓库，国内有点不好使。</li>
<li>可以参考 <a href="https://github.com/BurdenBear/kube-charts-mirror">kube-charts-mirror</a>，搭建一个自主可控的镜像源。</li>
</ul>
<p>添加存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add stable http://mirror.azure.cn/kubernetes/charts</span><br><span class="line">helm repo add aliyun https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts </span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure>

<p>查看配置的存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo list</span><br><span class="line">helm search repo stable</span><br></pre></td></tr></table></figure>

<p>一直在stable存储库中安装charts，你可以配置其他存储库。</p>
<p>删除存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo remove aliyun</span><br></pre></td></tr></table></figure>

<h2 id="Helm基本使用"><a href="#Helm基本使用" class="headerlink" title="Helm基本使用"></a>Helm基本使用</h2><p>主要介绍三个命令：</p>
<ul>
<li><p>chart install</p>
</li>
<li><p>chart update</p>
</li>
<li><p>chart rollback</p>
</li>
</ul>
<h3 id="使用chart部署一个应用"><a href="#使用chart部署一个应用" class="headerlink" title="使用chart部署一个应用"></a>使用chart部署一个应用</h3><p>查找chart：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm search repo</span><br><span class="line"># helm search repo mysql</span><br></pre></td></tr></table></figure>

<p>为什么mariadb也在列表中？因为他和mysql有关。</p>
<p>查看chart信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm show chart stable/mysql</span><br></pre></td></tr></table></figure>

<p>安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm install db stable/mysql</span><br></pre></td></tr></table></figure>

<p>查看发布状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm status db </span><br></pre></td></tr></table></figure>

<h3 id="安装前自定义chart配置选项"><a href="#安装前自定义chart配置选项" class="headerlink" title="安装前自定义chart配置选项"></a>安装前自定义chart配置选项</h3><p>上面部署的mysql并没有成功，这是因为并不是所有的chart都能按照默认配置运行成功，可能会需要一些环境依赖，例如PV。</p>
<p>所以我们需要自定义chart配置选项，安装过程中有两种方法可以传递配置数据：</p>
<ul>
<li>–values（或-f）：指定带有覆盖的YAML文件。这可以多次指定，最右边的文件优先</li>
<li>–set：在命令行上指定替代。如果两者都用，–set优先级高</li>
</ul>
<p>–values使用，先将修改的变量写到一个文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm show values stable/mysql</span><br><span class="line"># cat config.yaml </span><br><span class="line">persistence:  </span><br><span class="line">  enabled: true  </span><br><span class="line">  storageClass: &quot;managed-nfs-storage&quot;  </span><br><span class="line">  accessMode: ReadWriteOnce  </span><br><span class="line">  size: 8Gi</span><br><span class="line">  mysqlUser: &quot;k8s&quot;</span><br><span class="line">  mysqlPassword: &quot;123456&quot;</span><br><span class="line">  mysqlDatabase: &quot;k8s&quot;</span><br><span class="line">  </span><br><span class="line"># helm install db -f config.yaml stable/mysql</span><br><span class="line"># kubectl get pods</span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">db-mysql-57485b68dc-4xjhv        1/1     Running   0          8m51s</span><br></pre></td></tr></table></figure>

<p>以上将创建具有名称的默认MySQL用户k8s，并授予此用户访问新创建的k8s数据库的权限，但将接受该图表的所有其余默认值。</p>
<p>命令行替代变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm install db --set persistence.storageClass=&quot;managed-nfs-storage&quot; stable/mysql</span><br></pre></td></tr></table></figure>

<p>也可以把chart包下载下来查看详情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm pull stable/mysql --untar</span><br></pre></td></tr></table></figure>

<p>values yaml与set使用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/stupid-yu/cdn/img/helm-set-usage.png"></p>
<p><strong>该helm install命令可以从多个来源安装：</strong></p>
<ul>
<li>chart存储库</li>
<li>本地chart存档（helm install foo-0.1.1.tgz）</li>
<li>chart目录（helm install path/to/foo）</li>
<li>完整的URL（helm install <a href="https://example.com/charts/foo-1.2.3.tgz%EF%BC%89">https://example.com/charts/foo-1.2.3.tgz）</a></li>
</ul>
<h3 id="构建一个Helm-Chart"><a href="#构建一个Helm-Chart" class="headerlink" title="构建一个Helm Chart"></a>构建一个Helm Chart</h3><p>自动生成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm create mychart</span><br><span class="line">Creating mychart</span><br><span class="line"># tree mychart/</span><br><span class="line">mychart/</span><br><span class="line">├── charts</span><br><span class="line">├── Chart.yaml          </span><br><span class="line">├── templates</span><br><span class="line">│   ├── deployment.yaml</span><br><span class="line">│   ├── _helpers.tpl</span><br><span class="line">│   ├── ingress.yaml</span><br><span class="line">│   ├── NOTES.txt</span><br><span class="line">│   └── service.yaml</span><br><span class="line">└── values.yaml</span><br></pre></td></tr></table></figure>

<ul>
<li>Chart.yaml：用于描述这个 Chart的基本信息，包括名字、描述信息以及版本等。</li>
<li>values.yaml ：用于存储 templates 目录中模板文件中用到变量的值。</li>
<li>Templates： 目录里面存放所有yaml模板文件。</li>
<li>charts：目录里存放这个chart依赖的所有子chart。</li>
<li>NOTES.txt ：用于介绍Chart帮助信息， helm install 部署后展示给用户。例如：如何使用这个 Chart、列出缺省的设置等。</li>
<li>_helpers.tpl：放置模板助手的地方，可以在整个 chart 中重复使用</li>
</ul>
<p>创建Chart后，接下来就是将其部署：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm install web mychart/</span><br></pre></td></tr></table></figure>

<p>也可以打包推送的charts仓库共享别人使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm package mychart/mychart-0.1.0.tgz</span><br></pre></td></tr></table></figure>

<h3 id="升级、回滚和删除"><a href="#升级、回滚和删除" class="headerlink" title="升级、回滚和删除"></a>升级、回滚和删除</h3><p>发布新版本的chart时，或者当您要更改发布的配置时，可以使用该<code>helm upgrade</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm upgrade --set imageTag=1.17 web mychart</span><br><span class="line"># helm upgrade -f values.yaml web mychart</span><br></pre></td></tr></table></figure>

<p>如果在发布后没有达到预期的效果，则可以使用<code>helm rollback </code>回滚到之前的版本。</p>
<p>例如将应用回滚到第一个版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm rollback web 2</span><br></pre></td></tr></table></figure>

<p>卸载发行版，请使用以下<code>helm uninstall</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm uninstall web</span><br></pre></td></tr></table></figure>

<p>查看历史版本配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm get --revision 1 web</span><br></pre></td></tr></table></figure>

<h2 id="Chart模板"><a href="#Chart模板" class="headerlink" title="Chart模板"></a>Chart模板</h2><p>Helm最核心的就是模板，即模板化的K8S manifests文件。</p>
<p>它本质上就是一个Go的template模板。Helm在Go template模板的基础上，还会增加很多东西。如一些自定义的元数据信息、扩展的库以及一些类似于编程形式的工作流，例如条件语句、管道等等。这些东西都会使得我们的模板变得更加丰富。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>有了模板，我们怎么把我们的配置融入进去呢？用的就是这个values文件。这两部分内容其实就是chart的核心功能。</p>
<p>接下来，部署nginx应用，熟悉模板使用，先把templates 目录下面所有文件全部删除掉，这里我们自己来创建模板文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rm -rf mychart/templates/*</span><br><span class="line"># vi templates/deployment.yaml</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:1.16</span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure>

<p>实际上，这已经是一个可安装的Chart包了，通过 <code>helm install</code>命令来进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm install web mychart</span><br></pre></td></tr></table></figure>

<p>这样部署，其实与直接apply没什么两样。</p>
<p>然后使用如下命令可以看到实际的模板被渲染过后的资源文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm get manifest web</span><br></pre></td></tr></table></figure>

<p>可以看到，这与刚开始写的内容是一样的，包括名字、镜像等，我们希望能在一个地方统一定义这些会经常变换的字段，这就需要用到Chart的模板了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vi templates/deployment.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:1.16</span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure>

<p>这个deployment就是一个Go template的模板，这里定义的Release模板对象属于Helm内置的一种对象，是从values文件中读取出来的。这样一来，我们可以将需要变化的地方都定义变量。</p>
<p>再执行helm install chart 可以看到现在生成的名称变成了<strong>web-deployment</strong>，证明已经生效了。也可以使用命令helm get manifest查看最终生成的文件内容。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>Helm也提供了<code>--dry-run --debug</code>调试参数，帮助你验证模板正确性。在执行<code>helm install</code>时候带上这两个参数就可以把对应的values值和渲染的资源清单打印出来，而不会真正的去部署一个release。</p>
<p>比如我们来调试上面创建的 chart 包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm install web2 --dry-run /root/mychart</span><br></pre></td></tr></table></figure>

<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>刚刚我们使用 <code>&#123;&#123;.Release.Name&#125;&#125;</code>将 release 的名称插入到模板中。这里的 Release 就是 Helm 的内置对象，下面是一些常用的内置对象：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Release.Name</td>
<td>release 名称</td>
</tr>
<tr>
<td>Release.Namespace</td>
<td>release 命名空间</td>
</tr>
<tr>
<td>Release.Service</td>
<td>release 服务的名称</td>
</tr>
<tr>
<td>Release.Revision</td>
<td>release 修订版本号，从1开始累加</td>
</tr>
</tbody></table>
<h3 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h3><p>Values对象是为Chart模板提供值，这个对象的值有4个来源：</p>
<ul>
<li><p>chart 包中的 values.yaml 文件</p>
</li>
<li><p>父 chart 包的 values.yaml 文件</p>
</li>
<li><p>通过 helm install 或者 helm upgrade 的 <code>-f</code>或者 <code>--values</code>参数传入的自定义的 yaml 文件</p>
</li>
<li><p>通过 <code>--set</code> 参数传入的值</p>
</li>
</ul>
<p>chart 的 values.yaml 提供的值可以被用户提供的 values 文件覆盖，而该文件同样可以被 <code>--set</code>提供的参数所覆盖。</p>
<p>这里我们来重新编辑 mychart/values.yaml 文件，将默认的值全部清空，然后添加一个副本数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat values.yaml </span><br><span class="line">replicas: 3</span><br><span class="line">image: &quot;nginx&quot;</span><br><span class="line">imageTag: &quot;1.17&quot;</span><br><span class="line"></span><br><span class="line"># cat templates/deployment.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicas &#125;&#125;</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: &#123;&#123; .Values.image &#125;&#125;:&#123;&#123; .Values.imageTag &#125;&#125;</span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure>

<p>查看渲染结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm install --dry-run web ../mychart/</span><br></pre></td></tr></table></figure>

<p>values 文件也可以包含结构化内容，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat values.yaml </span><br><span class="line">...</span><br><span class="line">label:  </span><br><span class="line">  project: ms  </span><br><span class="line">  app: nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># cat templates/deployment.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-deployment </span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicas &#125;&#125; </span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      project: &#123;&#123; .Values.label.project &#125;&#125;</span><br><span class="line">      app: &#123;&#123; .Values.label.app &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        project: &#123;&#123; .Values.label.project &#125;&#125;</span><br><span class="line">        app: &#123;&#123; .Values.label.app &#125;&#125;</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: &#123;&#123; .Values.image &#125;&#125;:&#123;&#123; .Values.imageTag &#125;&#125; </span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure>

<p>查看渲染结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm install --dry-run web ../mychart/</span><br></pre></td></tr></table></figure>

<h3 id="管道与函数"><a href="#管道与函数" class="headerlink" title="管道与函数"></a>管道与函数</h3><p>前面讲的模块，其实就是将值传给模板引擎进行渲染，模板引擎还支持对拿到数据进行二次处理。</p>
<p>例如从.Values中读取的值变成字符串，可以使用<code>quote</code>函数实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vi templates/deployment.yaml</span><br><span class="line">app: &#123;&#123; quote .Values.label.app &#125;&#125;</span><br><span class="line"></span><br><span class="line"># helm install --dry-run web ../mychart/ </span><br><span class="line">        project: ms</span><br><span class="line">        app: &quot;nginx&quot;</span><br></pre></td></tr></table></figure>

<p>quote .Values.label.app 将后面的值作为参数传递给quote函数。</p>
<p>模板函数调用语法为：functionName arg1 arg2…</p>
<p>另外还会经常使用一个default函数，该函数允许在模板中指定默认值，以防止该值被忽略掉。</p>
<p>例如忘记定义，执行helm install 会因为缺少字段无法创建资源，这时就可以定义一个默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat values.yaml </span><br><span class="line">replicas: 2</span><br><span class="line"></span><br><span class="line"># cat templates/deployment.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:  </span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-deployment</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- name: &#123;&#123; .Values.name | default &quot;nginx&quot; &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缩进：&#123;&#123; .Values.resources | indent 12 &#125;&#125;</span><br><span class="line"></span><br><span class="line">大写：&#123;&#123; upper .Values.resources &#125;&#125;</span><br><span class="line"></span><br><span class="line">首字母大写：&#123;&#123; title .Values.resources &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>流程控制是为模板提供了一种能力，满足更复杂的数据逻辑处理。</p>
<p>Helm模板语言提供以下流程控制语句：</p>
<ul>
<li><code>if/else</code> 条件块</li>
<li><code>with</code> 指定范围</li>
<li><code>range</code> 循环块</li>
</ul>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><code>if/else</code>块是用于在模板中有条件地包含文本块的方法，条件块的基本结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; if PIPELINE &#125;&#125;</span><br><span class="line">  # Do something</span><br><span class="line">&#123;&#123; else if OTHER PIPELINE &#125;&#125;</span><br><span class="line">  # Do something else</span><br><span class="line">&#123;&#123; else &#125;&#125;</span><br><span class="line">  # Default case</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat values.yaml </span><br><span class="line">devops: k8</span><br><span class="line"></span><br><span class="line"># cat templates/deployment.yaml </span><br><span class="line">...</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">        &#123;&#123; if eq .Values.devops &quot;k8s&quot; &#125;&#125;</span><br><span class="line">        devops: 123</span><br><span class="line">        &#123;&#123; else &#125;&#125;</span><br><span class="line">        devops: 456</span><br><span class="line">        &#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在上面条件语句使用了<code>eq</code>运算符判断是否相等，除此之外，还支持<code>ne</code>、 <code>lt</code>、 <code>gt</code>、 <code>and</code>、 <code>or</code>等运算符。</p>
<p>通过模板引擎来渲染一下，会得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm install --dry-run web ../mychart/ </span><br><span class="line">...</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx  </span><br><span class="line">        devops: 456      </span><br></pre></td></tr></table></figure>

<p>可以看到渲染出来会有多余的空行，这是因为当模板引擎运行时，会将控制指令删除，所有之前占的位置也就空白了，需要使用<code>&#123;&#123;- if ...&#125;&#125; </code>的方式消除此空行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat templates/deploymemt.yaml</span><br><span class="line">...</span><br><span class="line">        env:</span><br><span class="line">        &#123;&#123;- if eq .Values.env.hello &quot;world&quot; &#125;&#125;</span><br><span class="line">          - name: hello</span><br><span class="line">            value: 123</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>现在是不是没有多余的空格了，如果使用<code>-&#125;&#125;</code>需谨慎，比如上面模板文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat templates/deploymemt.yaml</span><br><span class="line">...</span><br><span class="line">       env:</span><br><span class="line">        &#123;&#123;- if eq .Values.env.hello &quot;world&quot; -&#125;&#125;</span><br><span class="line">           - hello: true</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这会渲染成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env:- hello: true</span><br></pre></td></tr></table></figure>

<p>因为<code>-&#125;&#125;</code>它删除了双方的换行符。</p>
<p>条件判断就是判断条件是否为真，如果值为以下几种情况则为false：</p>
<ul>
<li><p>一个布尔类型的 <code>假</code></p>
</li>
<li><p>一个数字 <code>零</code></p>
</li>
<li><p>一个 <code>空</code>的字符串</p>
</li>
<li><p>一个 <code>nil</code>（空或 <code>null</code>）</p>
</li>
<li><p>一个空的集合（ <code>map</code>、 <code>slice</code>、 <code>tuple</code>、 <code>dict</code>、 <code>array</code>）</p>
</li>
</ul>
<p>除了上面的这些情况外，其他所有条件都为 <code>真</code>。</p>
<p>例如，判断一个空的数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat values.yaml </span><br><span class="line">resources: &#123;&#125;</span><br><span class="line">  # limits:</span><br><span class="line">  #   cpu: 100m</span><br><span class="line">  #   memory: 128Mi</span><br><span class="line">  # requests:</span><br><span class="line">  #   cpu: 100m</span><br><span class="line">  #   memory: 128Mi</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat templates/deploymemt.yaml</span><br><span class="line">...</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:1.16</span><br><span class="line">        name: nginx</span><br><span class="line">        &#123;&#123;- if .Values.resources &#125;&#125;</span><br><span class="line">        resources:</span><br><span class="line">&#123;&#123; toYaml .Values.resources | indent 10 &#125;&#125;</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>例如，判断一个布尔值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat values.yaml </span><br><span class="line">service:</span><br><span class="line">  type: ClusterIP</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">ingress:</span><br><span class="line">  enabled: true </span><br><span class="line">  host: example.ctnrs.com</span><br><span class="line"></span><br><span class="line"># cat templates/ingress.yaml </span><br><span class="line">&#123;&#123;- if .Values.ingress.enabled -&#125;&#125;</span><br><span class="line">apiVersion: networking.k8s.io/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: &#123;&#123; .Values.ingress.host &#125;&#125;</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: /</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">          servicePort: &#123;&#123; .Values.service.port &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>with ：控制变量作用域。</p>
<p>还记得之前我们的 <code>&#123;&#123;.Release.xxx&#125;&#125;</code>或者 <code>&#123;&#123;.Values.xxx&#125;&#125;</code>吗？其中的 <code>.</code>就是表示对当前范围的引用， <code>.Values</code>就是告诉模板在当前范围中查找 <code>Values</code>对象的值。而 <code>with</code>语句就可以来控制变量的作用域范围，其语法和一个简单的 <code>if</code>语句比较类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; with PIPELINE &#125;&#125;</span><br><span class="line">  #  restricted scope</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><code>with</code>语句可以允许将当前范围 <code>.</code>设置为特定的对象，比如我们前面一直使用的 <code>.Values.label</code>，我们可以使用 <code>with</code>来将 <code>.</code>范围指向 <code>.Values.label</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat values.yaml </span><br><span class="line">...</span><br><span class="line">replicas: 3</span><br><span class="line">label:</span><br><span class="line">  project: ms</span><br><span class="line">  app: nginx</span><br><span class="line"></span><br><span class="line"># cat templates/deployment.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      &#123;&#123;- with .Values.nodeSelector &#125;&#125;</span><br><span class="line">      nodeSelector:</span><br><span class="line">        team: &#123;&#123; .team &#125;&#125;</span><br><span class="line">        gpu: &#123;&#123; .gpu &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx:1.16</span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- with .Values.nodeSelector &#125;&#125;</span><br><span class="line">nodeSelector:</span><br><span class="line">  &#123;&#123;- toYaml . | nindent 8 &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>上面增加了一个 xxx的一个块，这样的话就可以在当前的块里面直接引用 <code>.team</code>和 <code>.gpu</code>了。</p>
<p> <strong>with</strong>是一个循环构造。使用**.Values.nodeSelector中**的值：将其转换为Yaml。 </p>
<p> toYaml之后的点是循环中**.Values.nodeSelector**的当前值 </p>
<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>在 Helm 模板语言中，使用 <code>range</code>关键字来进行循环操作。</p>
<p>我们在 <code>values.yaml</code>文件中添加上一个变量列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat values.yaml </span><br><span class="line">test:</span><br><span class="line">  - 1</span><br><span class="line">  - 2</span><br><span class="line">  - 3</span><br></pre></td></tr></table></figure>

<p>循环打印该列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">data:</span><br><span class="line">  test: |</span><br><span class="line">  &#123;&#123;- range .Values.test &#125;&#125;</span><br><span class="line">    &#123;&#123; . &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>循环内部我们使用的是一个 <code>.</code>，这是因为当前的作用域就在当前循环内，这个 <code>.</code>引用的当前读取的元素。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>接下来学习一个语言中基本的概念：<strong>变量</strong>，在模板中，使用变量的场合不多，但我们将看到如何使用它来简化代码，并更好地利用with和range。</p>
<p><strong>问题1：获取列表键值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat ../values.yaml</span><br><span class="line">env:</span><br><span class="line">  NAME: &quot;gateway&quot;</span><br><span class="line">  JAVA_OPTS: &quot;-Xmx1G&quot;</span><br><span class="line"> </span><br><span class="line"># cat deployment.yaml </span><br><span class="line">...</span><br><span class="line">env:</span><br><span class="line">&#123;&#123;- range $k, $v := .Values.env &#125;&#125;</span><br><span class="line">  - name: &#123;&#123; $k &#125;&#125;</span><br><span class="line">    value: &#123;&#123; $v | quote &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env:</span><br><span class="line">- name: JAVA_OPTS</span><br><span class="line">  value: &quot;-Xmx1G&quot;</span><br><span class="line">- name: NAME</span><br><span class="line">  value: &quot;gateway&quot;</span><br></pre></td></tr></table></figure>

<p>上面在 <code>range</code>循环中使用 <code>$key</code>和 <code>$value</code>两个变量来接收后面列表循环的键和值<code>。</code></p>
<p><strong>问题2：with中不能使用内置对象</strong></p>
<p><code>with</code>语句块内不能再 <code>.Release.Name</code>对象，否则报错。</p>
<p>我们可以将该对象赋值给一个变量可以来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-deployment</span><br><span class="line">spec:</span><br><span class="line">  replicas: &#123;&#123; .Values.replicas &#125;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        project: &#123;&#123; .Values.label.project &#125;&#125;</span><br><span class="line">        app: &#123;&#123; quote .Values.label.app &#125;&#125;</span><br><span class="line">      &#123;&#123;- with .Values.label &#125;&#125;</span><br><span class="line">        project: &#123;&#123; .project &#125;&#125;</span><br><span class="line">        app: &#123;&#123; .app &#125;&#125;</span><br><span class="line">        release: &#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>上面会出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- $releaseName := .Release.Name -&#125;&#125;</span><br><span class="line">&#123;&#123;- with .Values.label &#125;&#125;</span><br><span class="line">  project: &#123;&#123; .project &#125;&#125;</span><br><span class="line">  app: &#123;&#123; .app &#125;&#125;</span><br><span class="line">  release: &#123;&#123; $releaseName &#125;&#125;</span><br><span class="line">  # 或者可以使用$符号,引入全局命名空间</span><br><span class="line">  release: &#123;&#123; $.Release.Name &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在 <code>with</code>语句上面增加了一句 <code>&#123;&#123;-$releaseName:=.Release.Name-&#125;&#125;</code>，其中 <code>$releaseName</code>就是后面的对象的一个引用变量，它的形式就是 <code>$name</code>，赋值操作使用 <code>:=</code>，这样 <code>with</code>语句块内部的 <code>$releaseName</code>变量仍然指向的是 <code>.Release.Name</code></p>
<h3 id="命名模板"><a href="#命名模板" class="headerlink" title="命名模板"></a>命名模板</h3><p>命名模板：使用define定义，template引入，在templates目录中默认下划线_开头的文件为公共模板(_helpers.tpl)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat _helpers.tpl</span><br><span class="line">&#123;&#123;- define &quot;demo.fullname&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- .Chart.Name -&#125;&#125;-&#123;&#123; .Release.Name &#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line"></span><br><span class="line"># cat deployment.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; template &quot;demo.fullname&quot; . &#125;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>template指令是将一个模板包含在另一个模板中的方法。但是，template函数不能用于Go模板管道。为了解决该问题，增加include功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat _helpers.tpl</span><br><span class="line">&#123;&#123;- define &quot;demo.labels&quot; -&#125;&#125;</span><br><span class="line">app: &#123;&#123; template &quot;demo.fullname&quot; . &#125;&#125;</span><br><span class="line">chart: &quot;&#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version &#125;&#125;&quot;</span><br><span class="line">release: &quot;&#123;&#123; .Release.Name &#125;&#125;&quot;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line"></span><br><span class="line"># cat deployment.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; include &quot;demo.fullname&quot; . &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- include &quot;demo.labels&quot; . | nindent 4 &#125;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面包含一个名为 <code>demo.labels</code> 的模板，然后将值 <code>.</code> 传递给模板，最后将该模板的输出传递给 <code>nindent</code> 函数。</p>
<h2 id="开发自己的Chart：Java应用为例"><a href="#开发自己的Chart：Java应用为例" class="headerlink" title="开发自己的Chart：Java应用为例"></a>开发自己的Chart：Java应用为例</h2><ol>
<li><p>先创建模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm create demo</span><br></pre></td></tr></table></figure></li>
<li><p>修改Chart.yaml，Values.yaml，添加常用的变量</p>
</li>
<li><p>在templates目录下创建部署镜像所需要的yaml文件，并变量引用yaml里经常变动的字段</p>
</li>
</ol>
<h2 id="使用Harbor作为Chart仓库"><a href="#使用Harbor作为Chart仓库" class="headerlink" title="使用Harbor作为Chart仓库"></a>使用Harbor作为Chart仓库</h2><p><strong>1、启用Harbor的Chart仓库服务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ./install.sh --with-chartmuseum</span><br></pre></td></tr></table></figure>

<p>启用后，默认创建的项目就带有helm charts功能了。</p>
<p><strong>2、安装push插件</strong></p>
<p> <a href="https://github.com/chartmuseum/helm-push">https://github.com/chartmuseum/helm-push</a> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">helm plugin install https://github.com/chartmuseum/helm-push</span><br></pre></td></tr></table></figure>

<p><strong>3、添加repo</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helm repo add  --username admin --password Harbor12345 myrepo http://192.168.31.70/chartrepo/library</span><br></pre></td></tr></table></figure>

<p><strong>4、推送与安装Chart</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># helm push mysql-1.4.0.tgz --username=admin --password=Harbor12345 http://192.168.31.70/chartrepo/library</span><br><span class="line"># helm install web --version 1.4.0 myrepo/demo</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>helm</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle</title>
    <url>/2021/08/27/oracle/</url>
    <content><![CDATA[<h1 id="Oracle总结"><a href="#Oracle总结" class="headerlink" title="Oracle总结"></a>Oracle总结</h1>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 简介</title>
    <url>/2021/08/31/zookeeper/</url>
    <content><![CDATA[<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><blockquote>
<p>A Distributed Coordination Service for Distributed Applications</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>ZooKeeper: Because Coordinating Distributed Systems is a Zoo</p>
</blockquote>
<p><a href="https://zookeeper.apache.org/">ZooKeeper</a> 是分布式应用的分布式开源协调服务。</p>
<span id="more"></span>

<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>ZooKeeper 从设计模式的角度来理解：是一个基于观察者模式设计的分布式管理框架，它<em><strong>负责存储和管理大家都关心的数据</strong></em>，然后<em><strong>接受观察者的注册</strong></em>，一旦这些数据发生变化，ZooKeeper 就将<em><strong>负责通知已经在ZooKeeper上注册的那些观察者</strong></em>作出相应的反应。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><img src="https://cdn.jsdelivr.net/gh/stupid-yu/CDN/img/zkservice.jpg"></p>
<blockquote>
<p>Guarantees<br>ZooKeeper is very fast and very simple. Since its goal, though, is to be a basis for the construction of more complicated services, such as synchronization, it provides a set of guarantees. These are:</p>
<ul>
<li><p>Sequential Consistency - Updates from a client will be applied in the order that they were sent.</p>
</li>
<li><p>Atomicity - Updates either succeed or fail. No partial results.</p>
</li>
<li><p>Single System Image - A client will see the same view of the service regardless of the server that it connects to. i.e., a client will never see an older view of the system even if the client fails over to a different server with the same session.</p>
</li>
<li><p>Reliability - Once an update has been applied, it will persist from that time forward until a client overwrites the update.</p>
</li>
<li><p>Timeliness - The clients view of the system is guaranteed to be up-to-date within a certain time bound.</p>
</li>
</ul>
</blockquote>
<p>ZooKeeper： 一个 Leader,多个 Follower 组成的集群，集群中只要有半数以上节点存活，ZooKeeper 集群就能正常服务。所以 ZooKeeper 适合安装奇数台服务器。其特点总结如下：</p>
<ul>
<li>更新请求顺序执行，来自同一个 Client 的请求按其发送顺序依次执行。</li>
<li>全局数据一致性：每个 Server 保存一份相同的数据副本，Client 无论连接到哪个 Server，数据都是一致的。</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败。</li>
<li>可靠性，数据保存直到下次 Client 覆盖更新。</li>
<li>实时性，在一定时间范围内，Client 能读到最新的数据。</li>
</ul>
<h2 id="Data-model-and-the-hierarchical-namespace"><a href="#Data-model-and-the-hierarchical-namespace" class="headerlink" title="Data model and the hierarchical namespace"></a>Data model and the hierarchical namespace</h2><blockquote>
<p>The namespace provided by ZooKeeper is much like that of a standard file system. A name is a sequence of path elements separated by a slash (/). Every node in ZooKeeper’s namespace is identified by a path.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/stupid-yu/CDN/img/zknamespace.jpg"></p>
<p>ZooKeeper 数据结构与 Unix 文件系统类似，整体上可以看作一棵树，每个节点称作一个 ZNode。每一个 ZNode 默认能够存储 <em><strong>1MB</strong></em> 的数据，每个 ZNode 都可以通过<em><strong>其路径唯一标识</strong></em>。</p>
<h2 id="Simple-API"><a href="#Simple-API" class="headerlink" title="Simple API"></a>Simple API</h2><blockquote>
<p>One of the design goals of ZooKeeper is providing a very simple programming interface. As a result, it supports only these operations:</p>
</blockquote>
<ul>
<li>create : creates a node at a location in the tree</li>
<li>delete : deletes a node</li>
<li>exists : tests if a node exists at a location</li>
<li>get data : reads the data from a node</li>
<li>set data : writes data to a node</li>
<li>get children : retrieves a list of children of a node</li>
<li>sync : waits for data to be propagated </li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>统一命名服务</li>
<li>统一配置管理</li>
<li>统一集群管理</li>
<li>服务节点动态上下线</li>
<li>软负载均衡</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简言之，ZooKeeper = 文件系统 + 通知机制。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper 本地模式安装</title>
    <url>/2021/09/02/zookeeper-install-standalone/</url>
    <content><![CDATA[<h1 id="ZooKeeper-本地模式"><a href="#ZooKeeper-本地模式" class="headerlink" title="ZooKeeper 本地模式"></a>ZooKeeper 本地模式</h1><blockquote>
<p>Running ZooKeeper in standalone mode is convenient for evaluation, some development, and testing.</p>
</blockquote>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><blockquote>
<p>See <a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_systemReq">System Requirements</a> in the Admin guide.</p>
</blockquote>
<ul>
<li>ZooKeeper runs in Java, release 1.8 or greater (JDK 8 LTS, JDK 11 LTS, JDK 12 - Java 9 and 10 are not supported).</li>
</ul>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p><a href="http://archive.apache.org/dist/zookeeper/zookeeper-3.5.6/apache-zookeeper-3.5.6-bin.tar.gz">ZooKeeper-3.5.6</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/stupid-yu/cdn/img/zookeeper-3.5.6.png"></p>
<span id="more"></span>

<h2 id="Standalone-Operation"><a href="#Standalone-Operation" class="headerlink" title="Standalone Operation"></a>Standalone Operation</h2><h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压到指定目录 （root用户）</span></span><br><span class="line">[root@archtx Downloads]<span class="comment"># tar -zxvf apache-zookeeper-3.5.6-bin.tar.gz -C /opt/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改目录名称</span></span><br><span class="line">[root@archtx opt]<span class="comment"># mv apache-zookeeper-3.5.6-bin apache-zookeeper-3.5.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置修改 conf目录下zoo_sample.cfg =&gt; zoo.cfg</span></span><br><span class="line">[root@archtx conf]<span class="comment"># mv zoo_sample.cfg zoo.cfg</span></span><br></pre></td></tr></table></figure>

<h3 id="操作-ZooKeeper"><a href="#操作-ZooKeeper" class="headerlink" title="操作 ZooKeeper"></a>操作 ZooKeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动 ZooKeeper</span></span><br><span class="line">[root@archtx apache-zookeeper-3.5.6]<span class="comment"># bin/zkServer.sh start</span></span><br><span class="line">/usr/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/apache-zookeeper-3.5.6/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程是否启动</span></span><br><span class="line">[root@archtx apache-zookeeper-3.5.6]<span class="comment"># jps</span></span><br><span class="line">57045 Jps</span><br><span class="line">56919 QuorumPeerMain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">[root@archtx apache-zookeeper-3.5.6]<span class="comment"># bin/zkServer.sh status</span></span><br><span class="line">/usr/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/apache-zookeeper-3.5.6/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost.</span><br><span class="line">Mode: standalone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动客户端</span></span><br><span class="line">[root@archtx apache-zookeeper-3.5.6]<span class="comment"># bin/zkCli.sh </span></span><br><span class="line">/usr/bin/java</span><br><span class="line">Connecting to localhost:2181</span><br><span class="line">.....</span><br><span class="line">Welcome to ZooKeeper!</span><br><span class="line">2021-09-02 16:03:25,244 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):ClientCnxn<span class="variable">$SendThread</span>@1112] - Opening socket connection to server localhost/127.0.0.1:2181. Will not attempt to authenticate using SASL (unknown error)</span><br><span class="line">JLine support is enabled</span><br><span class="line">2021-09-02 16:03:25,317 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):ClientCnxn<span class="variable">$SendThread</span>@959] - Socket connection established, initiating session, client: /127.0.0.1:54148, server: localhost/127.0.0.1:2181</span><br><span class="line">2021-09-02 16:03:25,331 [myid:localhost:2181] - INFO  [main-SendThread(localhost:2181):ClientCnxn<span class="variable">$SendThread</span>@1394] - Session establishment complete on server localhost/127.0.0.1:2181, sessionid = 0x1000a8aa8090000, negotiated timeout = 30000</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:None path:null</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出客户端</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] quit</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:Closed <span class="built_in">type</span>:None path:null</span><br><span class="line">2021-09-02 16:05:57,776 [myid:] - INFO  [main-EventThread:ClientCnxn<span class="variable">$EventThread</span>@524] - EventThread shut down <span class="keyword">for</span> session: 0x1000a8aa8090000</span><br><span class="line">2021-09-02 16:05:57,776 [myid:] - INFO  [main:ZooKeeper@1422] - Session: 0x1000a8aa8090000 closed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止ZooKeeper</span></span><br><span class="line">[root@archtx apache-zookeeper-3.5.6]<span class="comment"># bin/zkServer.sh stop</span></span><br><span class="line">/usr/bin/java</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/apache-zookeeper-3.5.6/bin/../conf/zoo.cfg</span><br><span class="line">Stopping zookeeper ... STOPPED</span><br></pre></td></tr></table></figure>

<h2 id="配置参数解读"><a href="#配置参数解读" class="headerlink" title="配置参数解读"></a>配置参数解读</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-------------------zoo_sample.cfg content begin------------------</span><br><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir=/tmp/zookeeper</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>tickTime : the basic time unit in milliseconds used by ZooKeeper. It is used to do heartbeats and the minimum session timeout will be twice the tickTime.</p>
</li>
<li><p>dataDir : the location to store the in-memory database snapshots and, unless specified otherwise, the transaction log of updates to the database.</p>
</li>
<li><p>clientPort : the port to listen for client connections</p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">默认值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tickTime</td>
<td align="left">2000毫秒</td>
<td align="left">ZooKeeper 服务器和客户端通信心跳时间</td>
</tr>
<tr>
<td align="left">initLimit</td>
<td align="left">10 心跳数</td>
<td align="left">LF初始通信时限制(LF:Leader-Follower)</td>
</tr>
<tr>
<td align="left">syncLimit</td>
<td align="left">5 心跳数</td>
<td align="left">LF同步通信时限</td>
</tr>
<tr>
<td align="left">dataDir</td>
<td align="left">/tmp/zookeeper</td>
<td align="left">保存ZooKeeper中的数据，一般不用默认</td>
</tr>
<tr>
<td align="left">clientPort</td>
<td align="left">2181</td>
<td align="left">客户端连接端口，通常不做修改</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 认证机制</title>
    <url>/2021/11/29/kafka-authentication/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓认证，又称“验证”“鉴权”，英文是 authentication，是指通过一定的手段，完成对用户身份的确认。认证的主要目的是确认当前声称为某种身份的用户确实是所声称的用户。</p>
<blockquote>
<p>在计算机领域，经常和认证搞混的一个术语就是授权，英文是 authorization。授权一般是指对信息安全或计算机安全相关的资源定义与授予相应的访问权限。举个简单的例子来区分下两者：认证要解决的是你要证明你是谁的问题，授权要解决的则是你能做什么的问题。</p>
<p><strong>在 Kafka 中，认证和授权是两套独立的安全配置。</strong></p>
</blockquote>
<span id="more"></span>

<h2 id="Kafka-认证机制"><a href="#Kafka-认证机制" class="headerlink" title="Kafka 认证机制"></a>Kafka 认证机制</h2><p>自 0.9.0.0 版本开始，Kafka 正式引入了认证机制，用于实现基础的安全用户认证。Kafka 支持基于 SSL 和基于 SASL 的安全认证机制。</p>
<blockquote>
<p>目前来看，使用 SSL 做信道加密的情况更多一些，但使用 SSL 实现认证不如使用 SASL。</p>
<p>可以使用 SSL 来做通信加密，使用 SASL 来做 Kafka 的认证实现</p>
</blockquote>
<ul>
<li>基于 SSL 的认证主要是指 Broker 和客户端的双路认证（2-way authentication）。</li>
<li>Kafka 还支持通过 SASL 做客户端认证。</li>
</ul>
<blockquote>
<p>Kafka supports the following SASL mechanisms:</p>
<ul>
<li><a href="https://kafka.apache.org/24/documentation/#security_sasl_kerberos">GSSAPI</a> (Kerberos) (v0.9.0.0)</li>
<li><a href="https://kafka.apache.org/24/documentation/#security_sasl_plain">PLAIN</a> (v0.10.0.0)</li>
<li><a href="https://kafka.apache.org/24/documentation/#security_sasl_scram">SCRAM-SHA-256</a> (v0.10.2.0)</li>
<li><a href="https://kafka.apache.org/24/documentation/#security_sasl_scram">SCRAM-SHA-512</a> (v0.10.2.0)</li>
<li><a href="https://kafka.apache.org/24/documentation/#security_sasl_oauthbearer">OAUTHBEARER</a> (v2.0)</li>
</ul>
</blockquote>
<p>上面展示的四种是kafka官方推荐的SASL认证方式。</p>
<table>
<thead>
<tr>
<th align="left">认证方式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SASL/GSSAPI</td>
<td align="center">主要是给 Kerberos 用户使用的，如果当前已经有了Kerberos认证，只需要给集群中每个Broker和访问用户申请Principals，然后在Kafka的配置文件中开启Kerberos的支持即可，官方参考：[Authentication using SASL/Kerberos]。</td>
</tr>
<tr>
<td align="left">SASL/PLAIN</td>
<td align="center">是一种简单的用户名/密码身份验证机制，通常与TLS/SSL一起用于加密，以实现安全身份验证。是一种比较容易使用的方式，但是有一个很明显的缺点，这种方式会把用户账户文件配置到一个静态文件中，每次想要添加新的账户都<em><strong>需要重启Kafka</strong></em>去加载静态文件，才能使之生效，十分的不方便，官方参考[Authentication using SASL/PLAIN]。</td>
</tr>
<tr>
<td align="left">SASL/SCRAM</td>
<td align="center">通过将认证用户信息保存在 ZooKeeper 里面，从而动态的获取用户信息，相当于把ZK作为一个认证中心使用了。这种认证可以在使用过程中，使用 Kafka 提供的命令动态地创建和删除用户，无需重启整个集群，十分方便。官方参考[Authentication using SASL/SCRAM]。</td>
</tr>
<tr>
<td align="left">SASL/OAUTHBEARER</td>
<td align="center">kafka 2.0 版本引入的新认证机制，主要是为了实现与 OAuth 2 框架的集成。Kafka 不提倡单纯使用 OAUTHBEARER，因为它生成的不安全的 Json Web Token，必须配以 SSL 加密才能用在生产环境中。官方参考[Authentication using SASL/OAUTHBEARER] 。</td>
</tr>
</tbody></table>
<h3 id="认证机制总结"><a href="#认证机制总结" class="headerlink" title="认证机制总结"></a>认证机制总结</h3><p><img src="https://cdn.jsdelivr.net/gh/stupid-yu/CDN/img/kafka-authentication-mechanisms.jpg"></p>
<h2 id="SASL-SCRAM-SHA-256-配置实例"><a href="#SASL-SCRAM-SHA-256-配置实例" class="headerlink" title="SASL/SCRAM-SHA-256 配置实例"></a>SASL/SCRAM-SHA-256 配置实例</h2><h3 id="第-1-步：创建用户"><a href="#第-1-步：创建用户" class="headerlink" title="第 1 步：创建用户"></a>第 1 步：创建用户</h3><p>配置 SASL/SCRAM 的第一步，是创建能否连接 Kafka 集群的用户。</p>
<p>在本次测试中，创建 3 个用户，分别是 admin 用户、writer 用户和 reader 用户。admin 用户用于实现 Broker 间通信，writer 用户用于生产消息，reader 用户用于消费消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-configs.sh --zookeeper hp102:2181 --alter --add-config <span class="string">&#x27;SCRAM-SHA-256=[password=admin],SCRAM-SHA-512=[password=admin]&#x27;</span> --entity-type users --entity-name admin</span><br><span class="line"></span><br><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-configs.sh --zookeeper hp102:2181 --alter --add-config <span class="string">&#x27;SCRAM-SHA-256=[password=writer],SCRAM-SHA-512=[password=writer]&#x27;</span> --entity-type users --entity-name writer</span><br><span class="line"></span><br><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-configs.sh --zookeeper hp102:2181 --alter --add-config <span class="string">&#x27;SCRAM-SHA-256=[password=reader],SCRAM-SHA-512=[password=reader]&#x27;</span> --entity-type users --entity-name reader</span><br></pre></td></tr></table></figure>

<h3 id="第-2-步：创建-JAAS-文件"><a href="#第-2-步：创建-JAAS-文件" class="headerlink" title="第 2 步：创建 JAAS 文件"></a>第 2 步：创建 JAAS 文件</h3><p><code>kafka_server_jass.conf</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">KafkaServer</span> <span class="string">&#123;</span></span><br><span class="line"><span class="meta">org.apache.kafka.common.security.scram.ScramLoginModule</span> <span class="string">required</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">&quot;admin&quot;;</span></span><br><span class="line"><span class="attr">&#125;;</span></span><br></pre></td></tr></table></figure>

<h3 id="第-3-步：配置-server-properties"><a href="#第-3-步：配置-server-properties" class="headerlink" title="第 3 步：配置 server.properties"></a>第 3 步：配置 <code>server.properties</code></h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">listeners</span>=<span class="string">SASL_PLAINTEXT://hp102:9092</span></span><br><span class="line"></span><br><span class="line"><span class="meta">security.inter.broker.protocol</span>=<span class="string">SASL_PLAINTEXT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">sasl.mechanism.inter.broker.protocol</span>=<span class="string">SCRAM-SHA-256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">sasl.enabled.mechanisms</span>=<span class="string">SCRAM-SHA-256</span></span><br></pre></td></tr></table></figure>

<h3 id="第-4-步：启动Broker"><a href="#第-4-步：启动Broker" class="headerlink" title="第 4 步：启动Broker"></a>第 4 步：启动Broker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ KAFKA_OPTS=-Djava.security.auth.login.config=config/kafka_jaas.conf bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure>

<h3 id="第-5-步：创建Topic"><a href="#第-5-步：创建Topic" class="headerlink" title="第 5 步：创建Topic"></a>第 5 步：创建Topic</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-topic.sh --zookeeper hp102:2181 --create --topic topic-demo --partitions 2 --replication-factor 3</span><br></pre></td></tr></table></figure>

<h3 id="第-6-步：发送消息"><a href="#第-6-步：发送消息" class="headerlink" title="第 6 步：发送消息"></a>第 6 步：发送消息</h3><p><code>producer.conf</code>的配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">security.protocol</span>=<span class="string">SASL_PLAINTEXT</span></span><br><span class="line"><span class="meta">sasl.mechanism</span>=<span class="string">SCRAM-SHA-256</span></span><br><span class="line"><span class="meta">sasl.jaas.config</span>=<span class="string">org.apache.kafka.common.security.scram.ScramLoginModule required username=&quot;writer&quot; password=&quot;writer&quot;;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-console-producer.sh --broker-list hp102:9092 --topic topic-demo --producer.config config/producer.conf</span><br></pre></td></tr></table></figure>

<h3 id="第-7-步：消费消息"><a href="#第-7-步：消费消息" class="headerlink" title="第 7 步：消费消息"></a>第 7 步：消费消息</h3><p><code>consumer.conf</code>的配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">security.protocol</span>=<span class="string">SASL_PLAINTEXT</span></span><br><span class="line"><span class="meta">sasl.mechanism</span>=<span class="string">SCRAM-SHA-256</span></span><br><span class="line"><span class="meta">sasl.jaas.config</span>=<span class="string">org.apache.kafka.common.security.scram.ScramLoginModule required username=&quot;reader&quot; password=&quot;reader&quot;;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-console-consumer.sh --bootstrap-server hp102:9092 --topic topic-demo --consumer.config config/consumer.conf</span><br></pre></td></tr></table></figure>

<h2 id="SSL-配置实例"><a href="#SSL-配置实例" class="headerlink" title="SSL 配置实例"></a>SSL 配置实例</h2><h3 id="第1步：利用提供的kafka-generate-ssl-sh脚本"><a href="#第1步：利用提供的kafka-generate-ssl-sh脚本" class="headerlink" title="第1步：利用提供的kafka-generate-ssl.sh脚本"></a>第1步：利用提供的<code>kafka-generate-ssl.sh</code>脚本</h3><blockquote>
<p>或者选择官方提供的脚本<a href="https://raw.githubusercontent.com/confluentinc/confluent-platform-security-tools/master/kafka-generate-ssl.sh"><code>kafka-generate-ssl.sh</code></a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置环境变量</span></span><br><span class="line">BASE_DIR=/home/dev/testenv <span class="comment">#你需要修改此处</span></span><br><span class="line">CERT_OUTPUT_PATH=<span class="string">&quot;<span class="variable">$BASE_DIR</span>/certificates&quot;</span></span><br><span class="line">PASSWORD=test1234</span><br><span class="line">KEY_STORE=<span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/server.keystore.jks&quot;</span></span><br><span class="line">TRUST_STORE=<span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/server.truststore.jks&quot;</span></span><br><span class="line">CLIENT_KEY_STORE=<span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/client.keystore.jks&quot;</span></span><br><span class="line">CLIENT_TRUST_STORE=<span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/client.truststore.jks&quot;</span></span><br><span class="line">KEY_PASSWORD=<span class="variable">$PASSWORD</span></span><br><span class="line">STORE_PASSWORD=<span class="variable">$PASSWORD</span></span><br><span class="line">TRUST_KEY_PASSWORD=<span class="variable">$PASSWORD</span></span><br><span class="line">TRUST_STORE_PASSWORD=<span class="variable">$PASSWORD</span></span><br><span class="line">CERT_AUTH_FILE=<span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/ca-cert&quot;</span></span><br><span class="line">DAYS_VALID=365</span><br><span class="line">DNAME=<span class="string">&quot;CN=Hui Yu, OU=Bcdp, O=Bonc, L=Beijing, ST=Beijing, C=CN&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir -p <span class="variable">$CERT_OUTPUT_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1. 产生key和证书......&quot;</span></span><br><span class="line">keytool -keystore <span class="variable">$KEY_STORE</span> -<span class="built_in">alias</span> kafka-server -validity <span class="variable">$DAYS_VALID</span> -genkey -keyalg RSA \</span><br><span class="line">-storepass <span class="variable">$STORE_PASSWORD</span> -keypass <span class="variable">$KEY_PASSWORD</span> -dname <span class="string">&quot;<span class="variable">$DNAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line">keytool -keystore <span class="variable">$CLIENT_KEY_STORE</span> -<span class="built_in">alias</span> kafka-client -validity <span class="variable">$DAYS_VALID</span> -genkey -keyalg RSA \</span><br><span class="line">-storepass <span class="variable">$STORE_PASSWORD</span> -keypass <span class="variable">$KEY_PASSWORD</span> -dname <span class="string">&quot;<span class="variable">$DNAME</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2. 创建CA......&quot;</span></span><br><span class="line">openssl req -new -x509 -keyout <span class="variable">$CERT_OUTPUT_PATH</span>/ca-key -out <span class="string">&quot;<span class="variable">$CERT_AUTH_FILE</span>&quot;</span> -days <span class="string">&quot;<span class="variable">$DAYS_VALID</span>&quot;</span> \</span><br><span class="line">-passin pass:<span class="string">&quot;<span class="variable">$PASSWORD</span>&quot;</span> -passout pass:<span class="string">&quot;<span class="variable">$PASSWORD</span>&quot;</span> \</span><br><span class="line">-subj <span class="string">&quot;/C=CN/ST=Beijing/L=Beijing/O=Bonc/OU=Bcdp,CN=Hui Yu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;3. 添加CA文件到broker truststore......&quot;</span></span><br><span class="line">keytool -keystore <span class="string">&quot;<span class="variable">$TRUST_STORE</span>&quot;</span> -<span class="built_in">alias</span> CARoot \</span><br><span class="line">-importcert -file <span class="string">&quot;<span class="variable">$CERT_AUTH_FILE</span>&quot;</span> -storepass <span class="string">&quot;<span class="variable">$TRUST_STORE_PASSWORD</span>&quot;</span> -keypass <span class="string">&quot;<span class="variable">$TRUST_KEY_PASS</span>&quot;</span> -noprompt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;4. 添加CA文件到client truststore......&quot;</span></span><br><span class="line">keytool -keystore <span class="string">&quot;<span class="variable">$CLIENT_TRUST_STORE</span>&quot;</span> -<span class="built_in">alias</span> CARoot \</span><br><span class="line">-importcert -file <span class="string">&quot;<span class="variable">$CERT_AUTH_FILE</span>&quot;</span> -storepass <span class="string">&quot;<span class="variable">$TRUST_STORE_PASSWORD</span>&quot;</span> -keypass <span class="string">&quot;<span class="variable">$TRUST_KEY_PASS</span>&quot;</span> -noprompt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;5. 从keystore中导出集群证书......&quot;</span></span><br><span class="line">keytool -keystore <span class="string">&quot;<span class="variable">$KEY_STORE</span>&quot;</span> -<span class="built_in">alias</span> kafka-server -certreq -file <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/server-cert-file&quot;</span> \</span><br><span class="line">-storepass <span class="string">&quot;<span class="variable">$STORE_PASSWORD</span>&quot;</span> -keypass <span class="string">&quot;<span class="variable">$KEY_PASSWORD</span>&quot;</span> -noprompt</span><br><span class="line"></span><br><span class="line">keytool -keystore <span class="string">&quot;<span class="variable">$CLIENT_KEY_STORE</span>&quot;</span> -<span class="built_in">alias</span> kafka-client -certreq -file <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/client-cert-file&quot;</span> \</span><br><span class="line">-storepass <span class="string">&quot;<span class="variable">$STORE_PASSWORD</span>&quot;</span> -keypass <span class="string">&quot;<span class="variable">$KEY_PASSWORD</span>&quot;</span> -noprompt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;6. 使用CA签发证书......&quot;</span></span><br><span class="line">openssl x509 -req -CA <span class="string">&quot;<span class="variable">$CERT_AUTH_FILE</span>&quot;</span> -CAkey <span class="variable">$CERT_OUTPUT_PATH</span>/ca-key -<span class="keyword">in</span> <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/server-cert-file&quot;</span> \</span><br><span class="line">-out <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/server-cert-signed&quot;</span> -days <span class="string">&quot;<span class="variable">$DAYS_VALID</span>&quot;</span> -CAcreateserial -passin pass:<span class="string">&quot;<span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line"></span><br><span class="line">openssl x509 -req -CA <span class="string">&quot;<span class="variable">$CERT_AUTH_FILE</span>&quot;</span> -CAkey <span class="variable">$CERT_OUTPUT_PATH</span>/ca-key -<span class="keyword">in</span> <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/client-cert-file&quot;</span> \</span><br><span class="line">-out <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/client-cert-signed&quot;</span> -days <span class="string">&quot;<span class="variable">$DAYS_VALID</span>&quot;</span> -CAcreateserial -passin pass:<span class="string">&quot;<span class="variable">$PASSWORD</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;7. 导入CA文件到keystore......&quot;</span></span><br><span class="line">keytool -keystore <span class="string">&quot;<span class="variable">$KEY_STORE</span>&quot;</span> -<span class="built_in">alias</span> CARoot -import -file <span class="string">&quot;<span class="variable">$CERT_AUTH_FILE</span>&quot;</span> -storepass <span class="string">&quot;<span class="variable">$STORE_PASSWORD</span>&quot;</span> \</span><br><span class="line"> -keypass <span class="string">&quot;<span class="variable">$KEY_PASSWORD</span>&quot;</span> -noprompt</span><br><span class="line"></span><br><span class="line">keytool -keystore <span class="string">&quot;<span class="variable">$CLIENT_KEY_STORE</span>&quot;</span> -<span class="built_in">alias</span> CARoot -import -file <span class="string">&quot;<span class="variable">$CERT_AUTH_FILE</span>&quot;</span> -storepass <span class="string">&quot;<span class="variable">$STORE_PASSWORD</span>&quot;</span> \</span><br><span class="line"> -keypass <span class="string">&quot;<span class="variable">$KEY_PASSWORD</span>&quot;</span> -noprompt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;8. 导入已签发证书到keystore......&quot;</span></span><br><span class="line">keytool -keystore <span class="string">&quot;<span class="variable">$KEY_STORE</span>&quot;</span> -<span class="built_in">alias</span> kafka-server -import -file <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/server-cert-signed&quot;</span> \</span><br><span class="line"> -storepass <span class="string">&quot;<span class="variable">$STORE_PASSWORD</span>&quot;</span> -keypass <span class="string">&quot;<span class="variable">$KEY_PASSWORD</span>&quot;</span> -noprompt</span><br><span class="line"></span><br><span class="line">keytool -keystore <span class="string">&quot;<span class="variable">$CLIENT_KEY_STORE</span>&quot;</span> -<span class="built_in">alias</span> kafka-client -import -file <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/client-cert-signed&quot;</span> \</span><br><span class="line"> -storepass <span class="string">&quot;<span class="variable">$STORE_PASSWORD</span>&quot;</span> -keypass <span class="string">&quot;<span class="variable">$KEY_PASSWORD</span>&quot;</span> -noprompt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;9. 删除临时文件......&quot;</span></span><br><span class="line">rm <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/ca-cert.srl&quot;</span></span><br><span class="line">rm <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/server-cert-signed&quot;</span></span><br><span class="line">rm <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/client-cert-signed&quot;</span></span><br><span class="line">rm <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/server-cert-file&quot;</span></span><br><span class="line">rm <span class="string">&quot;<span class="variable">$CERT_OUTPUT_PATH</span>/client-cert-file&quot;</span></span><br></pre></td></tr></table></figure>

<p>该脚本主要的产出是 4 个文件，分别是：server.keystore.jks、server.truststore.jks、client.keystore.jks 和 client.truststore.jks。</p>
<p>你需要把以 server 开头的两个文件，拷贝到集群中的所有 Broker 机器上，把以 client 开头的两个文件，拷贝到所有要连接 Kafka 集群的客户端应用程序机器上。</p>
<h3 id="第-2-步：配置server-properties"><a href="#第-2-步：配置server-properties" class="headerlink" title="第 2 步：配置server.properties"></a>第 2 步：配置<code>server.properties</code></h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">listeners</span>=<span class="string">SSL://hp102:9093</span></span><br><span class="line"><span class="meta">ssl.truststore.location</span>=<span class="string">/home/dev/testenv/certificates/server.truststore.jks</span></span><br><span class="line"><span class="meta">ssl.truststore.password</span>=<span class="string">test1234</span></span><br><span class="line"><span class="meta">ssl.keystore.location</span>=<span class="string">/home/dev/testenv/certificates/server.keystore.jks</span></span><br><span class="line"><span class="meta">ssl.keystore.password</span>=<span class="string">test1234</span></span><br><span class="line"><span class="meta">security.inter.broker.protocol</span>=<span class="string">SSL</span></span><br><span class="line"><span class="meta">ssl.client.auth</span>=<span class="string">required</span></span><br><span class="line"><span class="meta">ssl.key.password</span>=<span class="string">test1234</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 若提示ssl handshake failed 配置</span></span><br><span class="line"><span class="comment"># 因为自 Kafka 2.0 版本开始，它默认会验证服务器端的主机名是否匹配 Broker 端证书里的主机名</span></span><br><span class="line"><span class="meta">ssl.endpoint.identification.algorithm</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="第-3-步：启动Broker"><a href="#第-3-步：启动Broker" class="headerlink" title="第 3 步：启动Broker"></a>第 3 步：启动Broker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure>

<h3 id="第-4-步：创建Topic"><a href="#第-4-步：创建Topic" class="headerlink" title="第 4 步：创建Topic"></a>第 4 步：创建Topic</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-topic.sh --zookeeper hp102:2181 --create --topic <span class="built_in">test</span> --partitions 2 --replication-factor 3</span><br></pre></td></tr></table></figure>

<h3 id="第-5-步：配置客户端的-SSL"><a href="#第-5-步：配置客户端的-SSL" class="headerlink" title="第 5 步：配置客户端的 SSL"></a>第 5 步：配置客户端的 SSL</h3><p><code>client-ssl.config</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">security.protocol</span>=<span class="string">SSL</span></span><br><span class="line"><span class="meta">ssl.truststore.location</span>=<span class="string">/home/dev/testenv/certificates/client.truststore.jks</span></span><br><span class="line"><span class="meta">ssl.truststore.password</span>=<span class="string">test1234</span></span><br><span class="line"><span class="meta">ssl.keystore.location</span>=<span class="string">/home/dev/testenv/certificates/server.keystore.jks</span></span><br><span class="line"><span class="meta">ssl.keystore.password</span>=<span class="string">test1234</span></span><br><span class="line"><span class="meta">ssl.key.password</span>=<span class="string">test1234</span></span><br><span class="line"><span class="meta">ssl.endpoint.identification.algorithm</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<h3 id="第-6-步：发送消息-1"><a href="#第-6-步：发送消息-1" class="headerlink" title="第 6 步：发送消息"></a>第 6 步：发送消息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-console-producer.sh --broker-list hp102:9093 --topic <span class="built_in">test</span> --producer.config config/client-ssl.config</span><br></pre></td></tr></table></figure>

<h3 id="第-7-步：消费消息-1"><a href="#第-7-步：消费消息-1" class="headerlink" title="第 7 步：消费消息"></a>第 7 步：消费消息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-console-consumer.sh --bootstrap-server hp102:9093 --topic <span class="built_in">test</span> --consumer.config config/client-ssl.config</span><br></pre></td></tr></table></figure>

<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="SSL-证书生成"><a href="#SSL-证书生成" class="headerlink" title="SSL 证书生成"></a>SSL 证书生成</h3><p>Kafka 允许 client 通过 SSL 连接。SSL默认情况下被禁止，但可以根据需要开启。</p>
<p>可以使用Java的keytool工具来完成，Keytool 是一个Java 数据证书的管理工具 ,Keytool 将密钥（key）和证书（certificates）存在一个称为keystore的文件中，在keystore里，包含两种数据： </p>
<p>  1). 密钥实体（Key entity）——密钥（secret key）又或者是私钥和配对公钥（采用非对称加密） </p>
<p>  2). 可信任的证书实体（trusted certificate entries）——只包含公钥</p>
<p>keytool相关指令说明：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-alias</td>
<td>别名，可自定义，这里叫kafkaserver</td>
</tr>
<tr>
<td>-keystore</td>
<td>指定密钥库的名称(就像数据库一样的证书库，可以有很多个证书，ca certs这个文件是jre自带的， 也可以使用其它文件名字，如果没有这个文件名字，它会创建这样一个)</td>
</tr>
<tr>
<td>-storepass</td>
<td>指定密钥库的密码</td>
</tr>
<tr>
<td>-keypass</td>
<td>指定别名条目的密码</td>
</tr>
<tr>
<td>-list</td>
<td>显示密钥库中的证书信息</td>
</tr>
<tr>
<td>-export</td>
<td>将别名指定的证书导出到文件</td>
</tr>
<tr>
<td>-file</td>
<td>参数指定导出到文件的文件名</td>
</tr>
<tr>
<td>-import</td>
<td>将已签名数字证书导入密钥库</td>
</tr>
<tr>
<td>-keypasswd</td>
<td>修改密钥库中指定条目口令</td>
</tr>
<tr>
<td>-dname</td>
<td>指定证书拥有者信息。其中，CN=主机名/域名,OU=组织单位名称,O=组织名称,L=城市或区域名称,ST=州或省份名称,C=单位的两字母国家代码</td>
</tr>
<tr>
<td>-keyalg</td>
<td>指定密钥的算法</td>
</tr>
<tr>
<td>-validity</td>
<td>指定创建的证书有效期多少天</td>
</tr>
<tr>
<td>-keysize</td>
<td>指定密钥长度</td>
</tr>
</tbody></table>
<p>Kafka集群的每个broker节点生成SSL密钥和证书</p>
<blockquote>
<p>集群中的每一台机器都有一个公私密钥对、一个标识该机器的证书</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -keystore server.keystore.jks -<span class="built_in">alias</span> kafka-server -validity 365 -genkey</span><br></pre></td></tr></table></figure>

<p>  执行命令时，输入first and last name，这里需要输入你的<strong>主机名</strong>，确保公用名（CN）与服务器的完全限定域名（FQDN）精确相匹配。</p>
<p>  client 拿 CN 与 DNS 域名进行比较以确保它确实连接到所需的服务器，而不是恶意的服务器。</p>
<h3 id="生成CA认证证书"><a href="#生成CA认证证书" class="headerlink" title="生成CA认证证书"></a>生成CA认证证书</h3><blockquote>
<p>为了保证整个证书的安全性，认证机构（CA）负责签发证书。</p>
<p>认证机构就像发行护照的政府，政府会对每张护照盖章，使得护照很难被伪造。其它，政府核实印章，以保证此护照是真实的。</p>
<p>类似的，CA签发证书，密码保证签署的证书在计算上很难被伪造。因此，只要CA是一个真正值得信赖的权威机构，客户就可以很高的保证他们正在连接到真实的机器。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -keyout ca-key -out ca-cert -days 365</span><br></pre></td></tr></table></figure>

<ul>
<li><em><strong>ca-cert</strong></em> : the certificate of the CA [CA证书]</li>
<li><em><strong>ca-key</strong></em>: the private key of the CA [CA私钥]</li>
</ul>
<h3 id="通过CA证书创建一个服务器端信任证书"><a href="#通过CA证书创建一个服务器端信任证书" class="headerlink" title="通过CA证书创建一个服务器端信任证书"></a>通过CA证书创建一个服务器端信任证书</h3><blockquote>
<p>有了信任证书才可以进行证书有效性的检测</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -keystore server.truststore.jks -<span class="built_in">alias</span> CARoot -import -file ca-cert</span><br></pre></td></tr></table></figure>

<h3 id="通过CA证书创建一个客户端端信任证书"><a href="#通过CA证书创建一个客户端端信任证书" class="headerlink" title="通过CA证书创建一个客户端端信任证书"></a>通过CA证书创建一个客户端端信任证书</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -keystore client.truststore.jks -<span class="built_in">alias</span> CARoot -import -file ca-cert</span><br></pre></td></tr></table></figure>

<h3 id="从密钥库导出证书服务器端证书cert-file"><a href="#从密钥库导出证书服务器端证书cert-file" class="headerlink" title="从密钥库导出证书服务器端证书cert-file"></a>从密钥库导出证书服务器端证书cert-file</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -keystore server.keystore.jks -<span class="built_in">alias</span> kafkaserver -certreq -file cert-file</span><br></pre></td></tr></table></figure>

<h3 id="通过CA证书给服务器端证书进行签名处理"><a href="#通过CA证书给服务器端证书进行签名处理" class="headerlink" title="通过CA证书给服务器端证书进行签名处理"></a>通过CA证书给服务器端证书进行签名处理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -CA ca-cert -CAkey ca-key -<span class="keyword">in</span> cert-file -out cert-signed -days 365 -CAcreateserial -passin pass:&#123;ca-password&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将CA证书导入到服务器端keystore"><a href="#将CA证书导入到服务器端keystore" class="headerlink" title="将CA证书导入到服务器端keystore"></a>将CA证书导入到服务器端keystore</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -keystore server.keystore.jks -<span class="built_in">alias</span> CARoot -import -file ca-cert</span><br></pre></td></tr></table></figure>

<h3 id="将已签名的服务器证书导入到服务器keystore"><a href="#将已签名的服务器证书导入到服务器keystore" class="headerlink" title="将已签名的服务器证书导入到服务器keystore"></a>将已签名的服务器证书导入到服务器keystore</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -keystore server.keystore.jks -<span class="built_in">alias</span> kafkaserver -import -file cert-signed</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分布式</category>
        <category>Messaging System</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka 授权机制</title>
    <url>/2021/11/29/kafka-authorization/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓授权，一般是指对与信息安全或计算机安全相关的资源授予访问权限，特别是<strong>存取</strong>控制。</p>
<p>具体到权限模型，常见的有四种。</p>
<ul>
<li>ACL：Access-Control List，访问控制列表。权限模型</li>
<li>RBAC：Role-Based Access Control，基于角色的权限控制。</li>
<li>ABAC：Attribute-Based Access Control，基于属性的权限控制。</li>
<li>PBAC：Policy-Based Access Control，基于策略的权限控制。</li>
</ul>
<p>权限模型在典型的互联网场景中，前两种模型应用得多，后面这两种则比较少用。</p>
<span id="more"></span>

<h2 id="Kafka-授权机制"><a href="#Kafka-授权机制" class="headerlink" title="Kafka 授权机制"></a>Kafka 授权机制</h2><p>Kafka 没有使用 RBAC 模型，它用的是 ACL 模型。简单来说，这种模型就是规定了什么用户对什么资源有什么样的访问权限。</p>
<blockquote>
<p><strong>Principal P is [Allowed/Denied] Operation O From Host H On Resource R</strong></p>
<ul>
<li>Principal：表示访问 Kafka 集群的用户。</li>
<li>Operation：表示一个具体的访问类型，如读写消息或创建主题等。</li>
<li>Host：表示连接 Kafka 集群的客户端应用程序 IP 地址。Host 支持星号占位符，表示所有 IP 地址。</li>
<li>Resource：表示 Kafka 资源类型。如果以2.3 版本为例，Resource 共有 5 种，分别是 TOPIC、CLUSTER、GROUP、TRANSACTIONALID 和 DELEGATION TOKEN。</li>
</ul>
</blockquote>
<p>当前，Kafka 提供了一个可插拔的授权实现机制。该机制会将你配置的所有 ACL 项保存在 ZooKeeper 下的 /kafka-acl 节点中。你可以通过 Kafka 自带的 kafka-acls 脚本动态地对 ACL 项进行增删改查，并让它立即生效。</p>
<h2 id="Kafka-ACL常用操作"><a href="#Kafka-ACL常用操作" class="headerlink" title="Kafka ACL常用操作"></a>Kafka ACL常用操作</h2><h3 id="配置-Broker-端-server-properties"><a href="#配置-Broker-端-server-properties" class="headerlink" title="配置 Broker 端 server.properties"></a>配置 Broker 端 <code>server.properties</code></h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># authorizer.class.name=kafka.security.auth.SimpleAclAuthorizer</span></span><br><span class="line"><span class="comment"># 设置ACL类(高于 2.4.0 版本推荐使用 AclAuthorizer)</span></span><br><span class="line"><span class="meta">authorizer.class.name</span>=<span class="string">kafka.security.authorizer.AclAuthorizer</span></span><br></pre></td></tr></table></figure>
<h3 id="超级用户（Super-User）"><a href="#超级用户（Super-User）" class="headerlink" title="超级用户（Super User）"></a>超级用户（Super User）</h3><p>在开启了 ACL 授权之后，你还必须显式地为不同用户设置访问某项资源的权限，否则，在默认情况下，没有配置任何 ACL 的资源是不能被访问的。不过，这里也有一个例外：超级用户能够访问所有的资源，即使你没有为它们设置任何 ACL 项。</p>
<p>在一个 Kafka 集群中设置超级用户，只需要在 Broker 端的配置文件 <code>server.properties</code> 中，设置 <code>super.users</code> 参数即可，比如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分号分割</span></span><br><span class="line"><span class="meta">super.users</span>=<span class="string">User:superuser1;User:superuser2</span></span><br></pre></td></tr></table></figure>

<p>除了设置 <code>super.users </code>参数，Kafka 还支持将所有用户都配置成超级用户的用法。如果我们在 <code>server.properties</code> 文件中设置 <code>allow.everyone.if.no.acl.found=true</code>，那么所有用户都可以访问没有设置任何 ACL 的资源。</p>
<p>不过不太建议进行这样的设置。毕竟，在生产环境中，特别是在那些对安全有较高要求的环境中，采用白名单机制要比黑名单机制更加令人放心。</p>
<h3 id="kafka-acls-脚本"><a href="#kafka-acls-脚本" class="headerlink" title="kafka-acls 脚本"></a>kafka-acls 脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为用户 Alice 增加了集群级别的所有权限</span></span><br><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-acls.sh --authorizer-properties zookeeper.connect=localhost:2181 --add --allow-principal User:Alice --operation All --topic <span class="string">&#x27;*&#x27;</span> --cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许所有的用户使用任意的 IP 地址读取名为 test-topic 的主题数据，同时也禁止 BadUser 用户和 10.205.96.119 的 IP 地址访问 test-topic 下的消息。</span></span><br><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-acls.sh --authorizer-properties zookeeper.connect=localhost:2181 --add --allow-principal User:<span class="string">&#x27;*&#x27;</span> --allow-host <span class="string">&#x27;*&#x27;</span> --deny-principal User:BadUser --deny-host 10.205.96.119 --operation Read --topic test-topic</span><br></pre></td></tr></table></figure>

<h3 id="授权机制能否单独使用"><a href="#授权机制能否单独使用" class="headerlink" title="授权机制能否单独使用"></a>授权机制能否单独使用</h3><p>关于授权，有一个很常见的问题是，Kafka 授权机制能不配置认证机制而单独使用吗？其实，这是可以的，只是你只能为 IP 地址设置权限。比如，下面这个命令会禁止运行在 127.0.0.1 IP 地址上的 Producer 应用向 test 主题发送数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-acls.sh --authorizer-properties zookeeper.connect=localhost:2181 --add --deny-principal User:* --deny-host 127.0.0.1 --operation Write --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="SSL-ACL-配置的实例"><a href="#SSL-ACL-配置的实例" class="headerlink" title="SSL + ACL 配置的实例"></a>SSL + ACL 配置的实例</h2><h3 id="SSL-配置"><a href="#SSL-配置" class="headerlink" title="SSL 配置"></a>SSL 配置</h3><blockquote>
<p>SSL 配置参考 kafka 认证机制 ssl部分。</p>
</blockquote>
<h3 id="ACL-配置"><a href="#ACL-配置" class="headerlink" title="ACL 配置"></a>ACL 配置</h3><h4 id="开启-ACL"><a href="#开启-ACL" class="headerlink" title="开启 ACL"></a>开启 ACL</h4><p>配置 Broker 端 <code>server.properties</code></p>
<p><code>bashauthorizer.class.name=kafka.security.auth.SimpleAclAuthorizer。</code></p>
<h4 id="白名单机制"><a href="#白名单机制" class="headerlink" title="白名单机制"></a>白名单机制</h4><p>建议采用白名单机制，这样的话，没有显式设置权限的用户就无权访问任何资源。</p>
<h4 id="授予-SSL-用户集群的权限"><a href="#授予-SSL-用户集群的权限" class="headerlink" title="授予 SSL 用户集群的权限"></a>授予 SSL 用户集群的权限</h4><p>使用 kafka-acls 脚本为 SSL 用户授予集群的权限，我们以前面的例子来进行一下说明。在配置 SSL 时，我们指定用户的 Distinguished Name 为 “CN=Hui Yu, OU=Bcdp, O=Bonc, L=Beijing, ST=Beijing, C=CN”。之前在设置 Broker 端参数时，我们指定了 <code>security.inter.broker.protocol=SSL</code>，即强制指定 Broker 间的通讯也采用 SSL 加密。如果不为指定的 Distinguished Name 授予集群操作的权限，你是无法成功启动 Broker 的。因此，你需要在启动 Broker 之前执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-acls.sh --authorizer-properties zookeeper.connect=localhost:2181 --add --allow-principal User:<span class="string">&quot;CN=Hui Yu,OU=Bcdp,O=Bonc,L=Beijing,ST=Beijing,C=CN&quot;</span> --operation All --cluster</span><br></pre></td></tr></table></figure>

<h4 id="授予客户端程序相应的权限"><a href="#授予客户端程序相应的权限" class="headerlink" title="授予客户端程序相应的权限"></a>授予客户端程序相应的权限</h4><p>你要为客户端程序授予相应的权限，比如为生产者授予 producer 权限，为消费者授予 consumer 权限。假设客户端要访问的主题名字是 test，那么命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-acls.sh --authorizer-properties zookeeper.connect=localhost:2181 --add --allow-principal User:<span class="string">&quot;CN=Hui Yu,OU=Bcdp,O=Bonc,L=Beijing,ST=Beijing,C=CN&quot;</span> --producer --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">[dev@hp102 kafka-2.4.1]$ bin/kafka-acls.sh --authorizer-properties zookeeper.connect=localhost:2181 --add --allow-principal User:<span class="string">&quot;CN=Hui Yu,OU=Bcdp,O=Bonc,L=Beijing,ST=Beijing,C=CN&quot;</span> --consumer --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>最好不要把其他权限授予客户端，比如创建主题的权限。</p>
</blockquote>
<p>总之，你授予的权限越少，你的 Kafka 集群就越安全。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>Q: 如果要让一个客户端能够查询消费者组的提交位移数据，你觉得应该授予它什么权限？</p>
<p>A: 消费者端的TOPIC的WRITE权限 [源码规定]</p>
<p>附:<br><img src="https://cdn.jsdelivr.net/gh/stupid-yu/CDN/img/kafka-acl.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>Messaging System</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka 简介</title>
    <url>/2021/11/29/kafka-intro/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.</p>
</blockquote>
<p>简言之，Apache Kafka 是一款开源的消息引擎系统。</p>
<p>消息引擎系统，通俗来讲，系统 A 发送消息给消息引擎系统，系统 B 从消息引擎系统中读取 A 发送的消息。</p>
<span id="more"></span>

<p>消息引擎模型：</p>
<ul>
<li>点对点模型</li>
<li>发布/订阅模型</li>
</ul>
<blockquote>
<p>Q: why 消息引擎 ?</p>
<p>A: 削峰填谷</p>
</blockquote>
<h3 id="Kafka-高可用"><a href="#Kafka-高可用" class="headerlink" title="Kafka 高可用"></a>Kafka 高可用</h3><ul>
<li>不同 Broker 分散运行在多个机器上</li>
<li>副本机制，相同的数据拷贝到多台机器上 </li>
</ul>
<h3 id="Kafka-副本机制"><a href="#Kafka-副本机制" class="headerlink" title="Kafka 副本机制"></a>Kafka 副本机制</h3><ul>
<li>Kafka 定义了两类副本：领导者副本（Leader Replica）和追随者副本（Follower Replica）</li>
<li>Producer 总是向 Leader Replica 写消息；而 Consumer 总是从 Leader Replica 读消息。</li>
<li>Follower Replica，它只做一件事：向 Leader Replica 发送请求，请求Leader把最新生产的消息发给它（异步消息拉取），保持与 Leader 的同步 。</li>
</ul>
<h3 id="Kafka-伸缩性"><a href="#Kafka-伸缩性" class="headerlink" title="Kafka 伸缩性"></a>Kafka 伸缩性</h3><blockquote>
<p>副本机制可以保证数据的持久化或消息不丢失，但没有解决伸缩性的问题。</p>
<p>什么是伸缩性呢？我们拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据以至于单台 Broker 机器都无法容纳了，此时应该怎么办呢？</p>
</blockquote>
<h3 id="Kafka-分区机制"><a href="#Kafka-分区机制" class="headerlink" title="Kafka 分区机制"></a>Kafka 分区机制</h3><ul>
<li>每个主题划分成多个分区（Partition），每个分区是一组<strong>有序</strong>的消息日志。</li>
<li>生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。</li>
<li>分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。</li>
<li>生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移 Offset的数据来表征。分区位移总是从 0 开始，假设一个生产者向一个空分区写入了 10 条消息，那么这 10 条消息的位移依次是 0、1、2、……、9（消息表征分区内的消息位置，它是不变的，即一旦消息被成功写入到一个分区上，它的位移值就是固定的了）。</li>
</ul>
<h3 id="Kafka-三层消息架构"><a href="#Kafka-三层消息架构" class="headerlink" title="Kafka 三层消息架构"></a>Kafka 三层消息架构</h3><ul>
<li>第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。</li>
<li>第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。</li>
<li>第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。</li>
<li>最后，客户端程序只能与分区的领导者副本进行交互。</li>
</ul>
<h3 id="由消息层-gt-Kafka-Broker-持久化数据"><a href="#由消息层-gt-Kafka-Broker-持久化数据" class="headerlink" title="由消息层 =&gt; Kafka Broker 持久化数据"></a>由消息层 =&gt; Kafka Broker 持久化数据</h3><blockquote>
<p>性能较好的顺序 I/O 写操作 [<strong>追加写入</strong>] ，避免了缓慢的随机 I/O 操作，是实现 Kafka 高吞吐量特性的一个重要手段。</p>
</blockquote>
<ul>
<li><p>Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。</p>
</li>
<li><p>通过日志段（Log Segment）机制。一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。</p>
</li>
<li><p>Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>Producer 和 Consumer 都是 Kafka 系统的 Clients</p>
</blockquote>
<ul>
<li>消息：Record。这里的消息就是指 Kafka 处理的主要对象。</li>
<li>主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务。</li>
<li>分区：Partition。一个有序不变的消息序列。每个主题下可以有多个分区。</li>
<li>消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值。</li>
<li>副本：Replica。Kafka 中同一条消息能够被拷贝到多个地方以提供数据冗余，这些地方就是所谓的副本。副本还分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用。</li>
<li>生产者：Producer。向主题发布新消息的应用程序。</li>
<li>消费者：Consumer。从主题订阅新消息的应用程序。</li>
<li>消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移。</li>
<li>消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐。</li>
<li>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段。</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><blockquote>
<p>Kafka 不像 MySQL 那样允许追随者副本对外提供读服务？</p>
<p><a href="https://www.zhihu.com/question/327925275/answer/705690755">https://www.zhihu.com/question/327925275/answer/705690755</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
</search>
